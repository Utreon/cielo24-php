<?php
/**
 * JobApi
 * PHP version 7.4
 *
 * @category Class
 * @package  Cielo24
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * Cielo24
 *
 * The cielo24 Web Services Platform API allows developers to easily integrate transcription, captioning and keyword extraction into their applications without having to use a manual web portal.
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: devs@cielo24.com
 * Generated by: https://openapi-generator.tech
 * OpenAPI Generator version: 6.0.1
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace Cielo24\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\ConnectException;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use Cielo24\ApiException;
use Cielo24\Configuration;
use Cielo24\HeaderSelector;
use Cielo24\ObjectSerializer;

/**
 * JobApi Class Doc Comment
 *
 * @category Class
 * @package  Cielo24
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */
class JobApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @var int Host index
     */
    protected $hostIndex;

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     * @param int             $hostIndex (Optional) host index to select the list of hosts if defined in the OpenAPI spec
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null,
        $hostIndex = 0
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: new Configuration();
        $this->headerSelector = $selector ?: new HeaderSelector();
        $this->hostIndex = $hostIndex;
    }

    /**
     * Set the host index
     *
     * @param int $hostIndex Host index (required)
     */
    public function setHostIndex($hostIndex): void
    {
        $this->hostIndex = $hostIndex;
    }

    /**
     * Get the host index
     *
     * @return int Host index
     */
    public function getHostIndex()
    {
        return $this->hostIndex;
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation addMediaFile
     *
     * @param  int $v v (required)
     * @param  string $job_id job_id (required)
     * @param  int $content_length content_length (required)
     * @param  \SplFileObject $body body (required)
     * @param  string $is_duplicate is_duplicate (optional, default to 'false')
     *
     * @throws \Cielo24\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Cielo24\Model\AddMediaResponse|\Cielo24\Model\ErrorResponse
     */
    public function addMediaFile($v, $job_id, $content_length, $body, $is_duplicate = 'false')
    {
        list($response) = $this->addMediaFileWithHttpInfo($v, $job_id, $content_length, $body, $is_duplicate);
        return $response;
    }

    /**
     * Operation addMediaFileWithHttpInfo
     *
     * @param  int $v (required)
     * @param  string $job_id (required)
     * @param  int $content_length (required)
     * @param  \SplFileObject $body (required)
     * @param  string $is_duplicate (optional, default to 'false')
     *
     * @throws \Cielo24\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Cielo24\Model\AddMediaResponse|\Cielo24\Model\ErrorResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function addMediaFileWithHttpInfo($v, $job_id, $content_length, $body, $is_duplicate = 'false')
    {
        $request = $this->addMediaFileRequest($v, $job_id, $content_length, $body, $is_duplicate);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Cielo24\Model\AddMediaResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Cielo24\Model\AddMediaResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Cielo24\Model\AddMediaResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('\Cielo24\Model\ErrorResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Cielo24\Model\ErrorResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Cielo24\Model\ErrorResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Cielo24\Model\AddMediaResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Cielo24\Model\AddMediaResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Cielo24\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation addMediaFileAsync
     *
     * @param  int $v (required)
     * @param  string $job_id (required)
     * @param  int $content_length (required)
     * @param  \SplFileObject $body (required)
     * @param  string $is_duplicate (optional, default to 'false')
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function addMediaFileAsync($v, $job_id, $content_length, $body, $is_duplicate = 'false')
    {
        return $this->addMediaFileAsyncWithHttpInfo($v, $job_id, $content_length, $body, $is_duplicate)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation addMediaFileAsyncWithHttpInfo
     *
     * @param  int $v (required)
     * @param  string $job_id (required)
     * @param  int $content_length (required)
     * @param  \SplFileObject $body (required)
     * @param  string $is_duplicate (optional, default to 'false')
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function addMediaFileAsyncWithHttpInfo($v, $job_id, $content_length, $body, $is_duplicate = 'false')
    {
        $returnType = '\Cielo24\Model\AddMediaResponse';
        $request = $this->addMediaFileRequest($v, $job_id, $content_length, $body, $is_duplicate);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'addMediaFile'
     *
     * @param  int $v (required)
     * @param  string $job_id (required)
     * @param  int $content_length (required)
     * @param  \SplFileObject $body (required)
     * @param  string $is_duplicate (optional, default to 'false')
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function addMediaFileRequest($v, $job_id, $content_length, $body, $is_duplicate = 'false')
    {
        // verify the required parameter 'v' is set
        if ($v === null || (is_array($v) && count($v) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $v when calling addMediaFile'
            );
        }
        // verify the required parameter 'job_id' is set
        if ($job_id === null || (is_array($job_id) && count($job_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $job_id when calling addMediaFile'
            );
        }
        // verify the required parameter 'content_length' is set
        if ($content_length === null || (is_array($content_length) && count($content_length) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $content_length when calling addMediaFile'
            );
        }
        if ($content_length > 10737418239) {
            throw new \InvalidArgumentException('invalid value for "$content_length" when calling JobApi.addMediaFile, must be smaller than or equal to 10737418239.');
        }

        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling addMediaFile'
            );
        }

        $resourcePath = '/job/add_media';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $v,
            'v', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $job_id,
            'job_id', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $is_duplicate,
            'is_duplicate', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);

        // header params
        if ($content_length !== null) {
            $headerParams['Content-Length'] = ObjectSerializer::toHeaderValue($content_length);
        }



        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['video/mp4']
            );
        }

        // for model (json/xml)
        if (isset($body)) {
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($body));
            } else {
                $httpBody = $body;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('api_token');
        if ($apiKey !== null) {
            $queryParams['api_token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation addMediaUrl
     *
     * @param  int $v v (required)
     * @param  string $job_id job_id (required)
     * @param  string $media_url media_url (required)
     * @param  string $is_duplicate is_duplicate (optional, default to 'false')
     *
     * @throws \Cielo24\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Cielo24\Model\AddMediaResponse|\Cielo24\Model\ErrorResponse
     */
    public function addMediaUrl($v, $job_id, $media_url, $is_duplicate = 'false')
    {
        list($response) = $this->addMediaUrlWithHttpInfo($v, $job_id, $media_url, $is_duplicate);
        return $response;
    }

    /**
     * Operation addMediaUrlWithHttpInfo
     *
     * @param  int $v (required)
     * @param  string $job_id (required)
     * @param  string $media_url (required)
     * @param  string $is_duplicate (optional, default to 'false')
     *
     * @throws \Cielo24\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Cielo24\Model\AddMediaResponse|\Cielo24\Model\ErrorResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function addMediaUrlWithHttpInfo($v, $job_id, $media_url, $is_duplicate = 'false')
    {
        $request = $this->addMediaUrlRequest($v, $job_id, $media_url, $is_duplicate);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Cielo24\Model\AddMediaResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Cielo24\Model\AddMediaResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Cielo24\Model\AddMediaResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('\Cielo24\Model\ErrorResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Cielo24\Model\ErrorResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Cielo24\Model\ErrorResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Cielo24\Model\AddMediaResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Cielo24\Model\AddMediaResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Cielo24\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation addMediaUrlAsync
     *
     * @param  int $v (required)
     * @param  string $job_id (required)
     * @param  string $media_url (required)
     * @param  string $is_duplicate (optional, default to 'false')
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function addMediaUrlAsync($v, $job_id, $media_url, $is_duplicate = 'false')
    {
        return $this->addMediaUrlAsyncWithHttpInfo($v, $job_id, $media_url, $is_duplicate)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation addMediaUrlAsyncWithHttpInfo
     *
     * @param  int $v (required)
     * @param  string $job_id (required)
     * @param  string $media_url (required)
     * @param  string $is_duplicate (optional, default to 'false')
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function addMediaUrlAsyncWithHttpInfo($v, $job_id, $media_url, $is_duplicate = 'false')
    {
        $returnType = '\Cielo24\Model\AddMediaResponse';
        $request = $this->addMediaUrlRequest($v, $job_id, $media_url, $is_duplicate);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'addMediaUrl'
     *
     * @param  int $v (required)
     * @param  string $job_id (required)
     * @param  string $media_url (required)
     * @param  string $is_duplicate (optional, default to 'false')
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function addMediaUrlRequest($v, $job_id, $media_url, $is_duplicate = 'false')
    {
        // verify the required parameter 'v' is set
        if ($v === null || (is_array($v) && count($v) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $v when calling addMediaUrl'
            );
        }
        // verify the required parameter 'job_id' is set
        if ($job_id === null || (is_array($job_id) && count($job_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $job_id when calling addMediaUrl'
            );
        }
        // verify the required parameter 'media_url' is set
        if ($media_url === null || (is_array($media_url) && count($media_url) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $media_url when calling addMediaUrl'
            );
        }

        $resourcePath = '/job/add_media';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $v,
            'v', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $job_id,
            'job_id', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $media_url,
            'media_url', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $is_duplicate,
            'is_duplicate', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('api_token');
        if ($apiKey !== null) {
            $queryParams['api_token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation authorizeJob
     *
     * @param  int $v v (required)
     * @param  string $job_id job_id (required)
     *
     * @throws \Cielo24\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function authorizeJob($v, $job_id)
    {
        $this->authorizeJobWithHttpInfo($v, $job_id);
    }

    /**
     * Operation authorizeJobWithHttpInfo
     *
     * @param  int $v (required)
     * @param  string $job_id (required)
     *
     * @throws \Cielo24\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function authorizeJobWithHttpInfo($v, $job_id)
    {
        $request = $this->authorizeJobRequest($v, $job_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Cielo24\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation authorizeJobAsync
     *
     * @param  int $v (required)
     * @param  string $job_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function authorizeJobAsync($v, $job_id)
    {
        return $this->authorizeJobAsyncWithHttpInfo($v, $job_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation authorizeJobAsyncWithHttpInfo
     *
     * @param  int $v (required)
     * @param  string $job_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function authorizeJobAsyncWithHttpInfo($v, $job_id)
    {
        $returnType = '';
        $request = $this->authorizeJobRequest($v, $job_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'authorizeJob'
     *
     * @param  int $v (required)
     * @param  string $job_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function authorizeJobRequest($v, $job_id)
    {
        // verify the required parameter 'v' is set
        if ($v === null || (is_array($v) && count($v) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $v when calling authorizeJob'
            );
        }
        // verify the required parameter 'job_id' is set
        if ($job_id === null || (is_array($job_id) && count($job_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $job_id when calling authorizeJob'
            );
        }

        $resourcePath = '/job/authorize';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $v,
            'v', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $job_id,
            'job_id', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);




        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('api_token');
        if ($apiKey !== null) {
            $queryParams['api_token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getCaption
     *
     * @param  int $v v (required)
     * @param  string $job_id job_id (required)
     * @param  string $caption_format caption_format (required)
     * @param  string $build_url Rather than returning the file, return a permanent URL to the file. (optional, default to 'false')
     * @param  int $caption_words_min Minimum number of words allowed in a caption. (optional, default to 1)
     * @param  string $caption_by_sentence When true, puts each sentence into its own caption. When false, more than one sentence may appear in a single caption. (optional, default to 'true')
     * @param  int $characters_per_caption_line Maximum number of characters to be displayed on each caption line. (optional, default to 42)
     * @param  string $dfxp_header Allows you to specify a custom header for your DFXP caption file. The header should be the entire contents of the header including the opening and closing tags. Ignored if caption_format does not equal DFXP. (optional, default to '')
     * @param  string $disallow_dangling Will prevent captions from having the last word in a sentence start a new line. Last words will ALWAYS be kept on the same line, even if it breaks the characters_per_caption_line option. (optional, default to 'false')
     * @param  string $display_effects_speaker_as Determines what speaker name should used for sound effects. (optional, default to 'Effects')
     * @param  string $display_speaker_id Determines the way speakers are identified in the captions. Choose \&quot;no\&quot; to not display speaker identities at all: \&quot;&gt;&gt; example\&quot; Choose \&quot;number\&quot; to display only the speaker number: \&quot;&gt;&gt; Speaker 1: example\&quot; Choose \&quot;name\&quot; to display the speaker name: \&quot;&gt;&gt; John Doe: example\&quot;. If you choose \&quot;name\&quot;, the speaker number will be displayed if the name is not available. (optional, default to 'name')
     * @param  string $iwp_name The named version of element list to generate the transcript from. If not specified, the transcript will be generated from the latest version. (optional, default to '')
     * @param  string $elementlist_version The version of element list to generate the captions from. If not specified, the caption will be generated from the latest version. (ISO 8601 Date String) (optional, default to '')
     * @param  string $emit_speaker_change_tokens_as Determine what characters to use to denote speaker changes. (optional, default to '>>')
     * @param  string $force_case Force the contents of the captions to be all UPPER or lower case. If blank, the case of the captions is not changed. (optional, default to '')
     * @param  string $include_dfxp_metadata When true, and the caption format requested is DFXP, the jobs name, ID and language will be added to the DFXP metadata header. When false, these data are omitted from the header. Ignored if caption_format does not equal DFXP. (optional, default to 'true')
     * @param  int $layout_target_caption_length_ms Captions generated will, on average, be this duration. However, they may vary significantly based on other parameters you set. (optional, default to 5000)
     * @param  string $line_break_on_sentence Inserts a line break in between sentences that are in the same caption. (optional, default to 'false')
     * @param  string $line_ending_format Determine the end of line (EOL) character to use for the captions. (optional, default to 'UNIX')
     * @param  int $lines_per_caption Number of lines to be displayed for each caption. (optional, default to 2)
     * @param  string $mask_profanity Replace profanity with asterisks. (optional, default to 'false')
     * @param  int $maximum_caption_duration No captions longer than this (in milliseconds) will be produced. If not specified, there is no maximum. (optional)
     * @param  int $merge_gap_interval Captions with a gap between them that is smaller than this (in milliseconds) will have their start and/or end times changed so there is no time gap between the captions. (optional, default to 1000)
     * @param  int $minimum_caption_length_ms Extends the duration of short captions to the this minimum length. Additional time is taken from later caption blocks to meet this minimum time. (optional)
     * @param  int $minimum_gap_between_captions_ms Adds a minimum time between captions such as there will always be some time between captions where no text is displayed. When captions are very close together, time will be removed from the caption duration to make the gap. (optional)
     * @param  string $qt_seamless Does not put time gaps of any kind between caption blocks. Ignored if caption_format does not equal QT. (optional, default to 'false')
     * @param  string $remove_disfluencies Remove verbal disfluencies from the generated transcript. Common disfluencies such as \&quot;um\&quot; and \&quot;ah\&quot; are removed while maintaining appropriate punctuation. (optional, default to 'true')
     * @param  string[] $remove_sounds_list A list of sounds to not show in the caption. This is a JSON style list, and should look like [\&quot;MUSIC\&quot;, \&quot;LAUGH\&quot;]. Ignored if remove_sound_references is true. (optional)
     * @param  string $remove_sound_references Remove ALL non-verbal sound and noise references from the generated transcript. Sounds and unidentified noises are depicted in the caption as [SOUND], [COUGH] and [NOISE]. If this parameter is set, these identifiers are omitted from the caption. (optional, default to 'true')
     * @param  string $replace_slang Replace common slang terms from the generated transcript. Common replacements are \&quot;want to\&quot; for \&quot;wanna\&quot;, \&quot;going to\&quot; for \&quot;gonna\&quot;, etc. (optional, default to 'false')
     * @param  int $silence_max_ms If there is a interval of silence in the middle of a sentence longer than this, then the caption will be split. (optional, default to 2000)
     * @param  string $single_speaker_per_caption When true, puts each speaker into its own caption. When false, more than one speaker may appear in a single caption. (optional, default to 'true')
     * @param  string[] $sound_boundaries Specifies the characters to surround sound references with. The default will generate sound references that look like this: [MUSIC]. (optional)
     * @param  int $sound_threshold Sound references that are longer than this threshold will be made their own caption entirely, and will not have any text included with them. If not set, Sound references will be included back to back with text no matter the duration of the sound. (optional)
     * @param  string $sound_tokens_by_caption If true, all sound references will always be in their own caption. If false, more than one sound reference may appear in a single caption. (optional, default to 'false')
     * @param  string $sound_tokens_by_line If true, all sound references will always be in their own line. If false, more than one sound reference may appear in a single line. (optional, default to 'false')
     * @param  string[] $sound_tokens_by_caption_list If non-empty, the specified sound references will always be in their own caption. If empty, more than one sound reference may appear in a single caption. Ignored if sound_tokens_by_caption is true. (optional)
     * @param  string[] $sound_tokens_by_line_list If non-empty, the specified sound references will always be in their own line. If empty, more than one sound reference may appear in a single line. Ignored if sound_tokens_by_line is true. (optional)
     * @param  string $speaker_on_new_line If true, a speaker change will cause a new caption to be made. If false, multiple speakers may appear in a single caption. (optional, default to 'true')
     * @param  string $srt_format If the caption format is SRT, determines what the caption blocks will look like. The default, prints caption blocks that look like this:    1:   00:00:06,060 --&gt; 00:00:16,060   This is the caption text.  You can alter the caption block by re-arranging or removing the substitution string values, shown enclosed in braces \&quot;{}\&quot; in the default value below. Substitution strings may used more than once if desired. Any text that is not a substitution string will be displayed as written. To add new lines, include a \\n. Note, you may need to escape the \\n with an extra backslash when encoding the request. (optional, default to '{caption_number:d}\n{start_hour:02d}:{start_minute:02d}:{start_second:02d},{start_millisecond:03d} -->{end_hour:02d}:{end_minute:02d}:{end_second:02d},{end_millisecond:03d}\n{caption_text}\n\n')
     * @param  string $strip_square_brackets Removes all square brackets like &#39;[&#39; or &#39;]&#39; from captions. By default square brackets surround sound references like &#39;[MUSIC]&#39;, but they may exist as part of the caption text as well. (optional, default to 'false')
     * @param  string $utf8_mark Adds a utf8 bytemark to the beginning of the caption. This should only be used if the system you are loading the caption files into needs a byte marker. The vast majority of systems do not. (optional, default to 'false')
     * @param  string $replace_english_spelling Replaces English spelling with location accurate spelling. i.e. Color --&gt; Colour  A: American  B: British  Z: British ize  U: Australian  C: Canadian (optional, default to 'A')
     *
     * @throws \Cielo24\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return string|\Cielo24\Model\ErrorResponse
     */
    public function getCaption($v, $job_id, $caption_format, $build_url = 'false', $caption_words_min = 1, $caption_by_sentence = 'true', $characters_per_caption_line = 42, $dfxp_header = '', $disallow_dangling = 'false', $display_effects_speaker_as = 'Effects', $display_speaker_id = 'name', $iwp_name = '', $elementlist_version = '', $emit_speaker_change_tokens_as = '>>', $force_case = '', $include_dfxp_metadata = 'true', $layout_target_caption_length_ms = 5000, $line_break_on_sentence = 'false', $line_ending_format = 'UNIX', $lines_per_caption = 2, $mask_profanity = 'false', $maximum_caption_duration = null, $merge_gap_interval = 1000, $minimum_caption_length_ms = null, $minimum_gap_between_captions_ms = null, $qt_seamless = 'false', $remove_disfluencies = 'true', $remove_sounds_list = null, $remove_sound_references = 'true', $replace_slang = 'false', $silence_max_ms = 2000, $single_speaker_per_caption = 'true', $sound_boundaries = null, $sound_threshold = null, $sound_tokens_by_caption = 'false', $sound_tokens_by_line = 'false', $sound_tokens_by_caption_list = null, $sound_tokens_by_line_list = null, $speaker_on_new_line = 'true', $srt_format = '{caption_number:d}\n{start_hour:02d}:{start_minute:02d}:{start_second:02d},{start_millisecond:03d} -->{end_hour:02d}:{end_minute:02d}:{end_second:02d},{end_millisecond:03d}\n{caption_text}\n\n', $strip_square_brackets = 'false', $utf8_mark = 'false', $replace_english_spelling = 'A')
    {
        list($response) = $this->getCaptionWithHttpInfo($v, $job_id, $caption_format, $build_url, $caption_words_min, $caption_by_sentence, $characters_per_caption_line, $dfxp_header, $disallow_dangling, $display_effects_speaker_as, $display_speaker_id, $iwp_name, $elementlist_version, $emit_speaker_change_tokens_as, $force_case, $include_dfxp_metadata, $layout_target_caption_length_ms, $line_break_on_sentence, $line_ending_format, $lines_per_caption, $mask_profanity, $maximum_caption_duration, $merge_gap_interval, $minimum_caption_length_ms, $minimum_gap_between_captions_ms, $qt_seamless, $remove_disfluencies, $remove_sounds_list, $remove_sound_references, $replace_slang, $silence_max_ms, $single_speaker_per_caption, $sound_boundaries, $sound_threshold, $sound_tokens_by_caption, $sound_tokens_by_line, $sound_tokens_by_caption_list, $sound_tokens_by_line_list, $speaker_on_new_line, $srt_format, $strip_square_brackets, $utf8_mark, $replace_english_spelling);
        return $response;
    }

    /**
     * Operation getCaptionWithHttpInfo
     *
     * @param  int $v (required)
     * @param  string $job_id (required)
     * @param  string $caption_format (required)
     * @param  string $build_url Rather than returning the file, return a permanent URL to the file. (optional, default to 'false')
     * @param  int $caption_words_min Minimum number of words allowed in a caption. (optional, default to 1)
     * @param  string $caption_by_sentence When true, puts each sentence into its own caption. When false, more than one sentence may appear in a single caption. (optional, default to 'true')
     * @param  int $characters_per_caption_line Maximum number of characters to be displayed on each caption line. (optional, default to 42)
     * @param  string $dfxp_header Allows you to specify a custom header for your DFXP caption file. The header should be the entire contents of the header including the opening and closing tags. Ignored if caption_format does not equal DFXP. (optional, default to '')
     * @param  string $disallow_dangling Will prevent captions from having the last word in a sentence start a new line. Last words will ALWAYS be kept on the same line, even if it breaks the characters_per_caption_line option. (optional, default to 'false')
     * @param  string $display_effects_speaker_as Determines what speaker name should used for sound effects. (optional, default to 'Effects')
     * @param  string $display_speaker_id Determines the way speakers are identified in the captions. Choose \&quot;no\&quot; to not display speaker identities at all: \&quot;&gt;&gt; example\&quot; Choose \&quot;number\&quot; to display only the speaker number: \&quot;&gt;&gt; Speaker 1: example\&quot; Choose \&quot;name\&quot; to display the speaker name: \&quot;&gt;&gt; John Doe: example\&quot;. If you choose \&quot;name\&quot;, the speaker number will be displayed if the name is not available. (optional, default to 'name')
     * @param  string $iwp_name The named version of element list to generate the transcript from. If not specified, the transcript will be generated from the latest version. (optional, default to '')
     * @param  string $elementlist_version The version of element list to generate the captions from. If not specified, the caption will be generated from the latest version. (ISO 8601 Date String) (optional, default to '')
     * @param  string $emit_speaker_change_tokens_as Determine what characters to use to denote speaker changes. (optional, default to '>>')
     * @param  string $force_case Force the contents of the captions to be all UPPER or lower case. If blank, the case of the captions is not changed. (optional, default to '')
     * @param  string $include_dfxp_metadata When true, and the caption format requested is DFXP, the jobs name, ID and language will be added to the DFXP metadata header. When false, these data are omitted from the header. Ignored if caption_format does not equal DFXP. (optional, default to 'true')
     * @param  int $layout_target_caption_length_ms Captions generated will, on average, be this duration. However, they may vary significantly based on other parameters you set. (optional, default to 5000)
     * @param  string $line_break_on_sentence Inserts a line break in between sentences that are in the same caption. (optional, default to 'false')
     * @param  string $line_ending_format Determine the end of line (EOL) character to use for the captions. (optional, default to 'UNIX')
     * @param  int $lines_per_caption Number of lines to be displayed for each caption. (optional, default to 2)
     * @param  string $mask_profanity Replace profanity with asterisks. (optional, default to 'false')
     * @param  int $maximum_caption_duration No captions longer than this (in milliseconds) will be produced. If not specified, there is no maximum. (optional)
     * @param  int $merge_gap_interval Captions with a gap between them that is smaller than this (in milliseconds) will have their start and/or end times changed so there is no time gap between the captions. (optional, default to 1000)
     * @param  int $minimum_caption_length_ms Extends the duration of short captions to the this minimum length. Additional time is taken from later caption blocks to meet this minimum time. (optional)
     * @param  int $minimum_gap_between_captions_ms Adds a minimum time between captions such as there will always be some time between captions where no text is displayed. When captions are very close together, time will be removed from the caption duration to make the gap. (optional)
     * @param  string $qt_seamless Does not put time gaps of any kind between caption blocks. Ignored if caption_format does not equal QT. (optional, default to 'false')
     * @param  string $remove_disfluencies Remove verbal disfluencies from the generated transcript. Common disfluencies such as \&quot;um\&quot; and \&quot;ah\&quot; are removed while maintaining appropriate punctuation. (optional, default to 'true')
     * @param  string[] $remove_sounds_list A list of sounds to not show in the caption. This is a JSON style list, and should look like [\&quot;MUSIC\&quot;, \&quot;LAUGH\&quot;]. Ignored if remove_sound_references is true. (optional)
     * @param  string $remove_sound_references Remove ALL non-verbal sound and noise references from the generated transcript. Sounds and unidentified noises are depicted in the caption as [SOUND], [COUGH] and [NOISE]. If this parameter is set, these identifiers are omitted from the caption. (optional, default to 'true')
     * @param  string $replace_slang Replace common slang terms from the generated transcript. Common replacements are \&quot;want to\&quot; for \&quot;wanna\&quot;, \&quot;going to\&quot; for \&quot;gonna\&quot;, etc. (optional, default to 'false')
     * @param  int $silence_max_ms If there is a interval of silence in the middle of a sentence longer than this, then the caption will be split. (optional, default to 2000)
     * @param  string $single_speaker_per_caption When true, puts each speaker into its own caption. When false, more than one speaker may appear in a single caption. (optional, default to 'true')
     * @param  string[] $sound_boundaries Specifies the characters to surround sound references with. The default will generate sound references that look like this: [MUSIC]. (optional)
     * @param  int $sound_threshold Sound references that are longer than this threshold will be made their own caption entirely, and will not have any text included with them. If not set, Sound references will be included back to back with text no matter the duration of the sound. (optional)
     * @param  string $sound_tokens_by_caption If true, all sound references will always be in their own caption. If false, more than one sound reference may appear in a single caption. (optional, default to 'false')
     * @param  string $sound_tokens_by_line If true, all sound references will always be in their own line. If false, more than one sound reference may appear in a single line. (optional, default to 'false')
     * @param  string[] $sound_tokens_by_caption_list If non-empty, the specified sound references will always be in their own caption. If empty, more than one sound reference may appear in a single caption. Ignored if sound_tokens_by_caption is true. (optional)
     * @param  string[] $sound_tokens_by_line_list If non-empty, the specified sound references will always be in their own line. If empty, more than one sound reference may appear in a single line. Ignored if sound_tokens_by_line is true. (optional)
     * @param  string $speaker_on_new_line If true, a speaker change will cause a new caption to be made. If false, multiple speakers may appear in a single caption. (optional, default to 'true')
     * @param  string $srt_format If the caption format is SRT, determines what the caption blocks will look like. The default, prints caption blocks that look like this:    1:   00:00:06,060 --&gt; 00:00:16,060   This is the caption text.  You can alter the caption block by re-arranging or removing the substitution string values, shown enclosed in braces \&quot;{}\&quot; in the default value below. Substitution strings may used more than once if desired. Any text that is not a substitution string will be displayed as written. To add new lines, include a \\n. Note, you may need to escape the \\n with an extra backslash when encoding the request. (optional, default to '{caption_number:d}\n{start_hour:02d}:{start_minute:02d}:{start_second:02d},{start_millisecond:03d} -->{end_hour:02d}:{end_minute:02d}:{end_second:02d},{end_millisecond:03d}\n{caption_text}\n\n')
     * @param  string $strip_square_brackets Removes all square brackets like &#39;[&#39; or &#39;]&#39; from captions. By default square brackets surround sound references like &#39;[MUSIC]&#39;, but they may exist as part of the caption text as well. (optional, default to 'false')
     * @param  string $utf8_mark Adds a utf8 bytemark to the beginning of the caption. This should only be used if the system you are loading the caption files into needs a byte marker. The vast majority of systems do not. (optional, default to 'false')
     * @param  string $replace_english_spelling Replaces English spelling with location accurate spelling. i.e. Color --&gt; Colour  A: American  B: British  Z: British ize  U: Australian  C: Canadian (optional, default to 'A')
     *
     * @throws \Cielo24\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of string|\Cielo24\Model\ErrorResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getCaptionWithHttpInfo($v, $job_id, $caption_format, $build_url = 'false', $caption_words_min = 1, $caption_by_sentence = 'true', $characters_per_caption_line = 42, $dfxp_header = '', $disallow_dangling = 'false', $display_effects_speaker_as = 'Effects', $display_speaker_id = 'name', $iwp_name = '', $elementlist_version = '', $emit_speaker_change_tokens_as = '>>', $force_case = '', $include_dfxp_metadata = 'true', $layout_target_caption_length_ms = 5000, $line_break_on_sentence = 'false', $line_ending_format = 'UNIX', $lines_per_caption = 2, $mask_profanity = 'false', $maximum_caption_duration = null, $merge_gap_interval = 1000, $minimum_caption_length_ms = null, $minimum_gap_between_captions_ms = null, $qt_seamless = 'false', $remove_disfluencies = 'true', $remove_sounds_list = null, $remove_sound_references = 'true', $replace_slang = 'false', $silence_max_ms = 2000, $single_speaker_per_caption = 'true', $sound_boundaries = null, $sound_threshold = null, $sound_tokens_by_caption = 'false', $sound_tokens_by_line = 'false', $sound_tokens_by_caption_list = null, $sound_tokens_by_line_list = null, $speaker_on_new_line = 'true', $srt_format = '{caption_number:d}\n{start_hour:02d}:{start_minute:02d}:{start_second:02d},{start_millisecond:03d} -->{end_hour:02d}:{end_minute:02d}:{end_second:02d},{end_millisecond:03d}\n{caption_text}\n\n', $strip_square_brackets = 'false', $utf8_mark = 'false', $replace_english_spelling = 'A')
    {
        $request = $this->getCaptionRequest($v, $job_id, $caption_format, $build_url, $caption_words_min, $caption_by_sentence, $characters_per_caption_line, $dfxp_header, $disallow_dangling, $display_effects_speaker_as, $display_speaker_id, $iwp_name, $elementlist_version, $emit_speaker_change_tokens_as, $force_case, $include_dfxp_metadata, $layout_target_caption_length_ms, $line_break_on_sentence, $line_ending_format, $lines_per_caption, $mask_profanity, $maximum_caption_duration, $merge_gap_interval, $minimum_caption_length_ms, $minimum_gap_between_captions_ms, $qt_seamless, $remove_disfluencies, $remove_sounds_list, $remove_sound_references, $replace_slang, $silence_max_ms, $single_speaker_per_caption, $sound_boundaries, $sound_threshold, $sound_tokens_by_caption, $sound_tokens_by_line, $sound_tokens_by_caption_list, $sound_tokens_by_line_list, $speaker_on_new_line, $srt_format, $strip_square_brackets, $utf8_mark, $replace_english_spelling);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('string' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('string' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'string', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('\Cielo24\Model\ErrorResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Cielo24\Model\ErrorResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Cielo24\Model\ErrorResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'string';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Cielo24\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getCaptionAsync
     *
     * @param  int $v (required)
     * @param  string $job_id (required)
     * @param  string $caption_format (required)
     * @param  string $build_url Rather than returning the file, return a permanent URL to the file. (optional, default to 'false')
     * @param  int $caption_words_min Minimum number of words allowed in a caption. (optional, default to 1)
     * @param  string $caption_by_sentence When true, puts each sentence into its own caption. When false, more than one sentence may appear in a single caption. (optional, default to 'true')
     * @param  int $characters_per_caption_line Maximum number of characters to be displayed on each caption line. (optional, default to 42)
     * @param  string $dfxp_header Allows you to specify a custom header for your DFXP caption file. The header should be the entire contents of the header including the opening and closing tags. Ignored if caption_format does not equal DFXP. (optional, default to '')
     * @param  string $disallow_dangling Will prevent captions from having the last word in a sentence start a new line. Last words will ALWAYS be kept on the same line, even if it breaks the characters_per_caption_line option. (optional, default to 'false')
     * @param  string $display_effects_speaker_as Determines what speaker name should used for sound effects. (optional, default to 'Effects')
     * @param  string $display_speaker_id Determines the way speakers are identified in the captions. Choose \&quot;no\&quot; to not display speaker identities at all: \&quot;&gt;&gt; example\&quot; Choose \&quot;number\&quot; to display only the speaker number: \&quot;&gt;&gt; Speaker 1: example\&quot; Choose \&quot;name\&quot; to display the speaker name: \&quot;&gt;&gt; John Doe: example\&quot;. If you choose \&quot;name\&quot;, the speaker number will be displayed if the name is not available. (optional, default to 'name')
     * @param  string $iwp_name The named version of element list to generate the transcript from. If not specified, the transcript will be generated from the latest version. (optional, default to '')
     * @param  string $elementlist_version The version of element list to generate the captions from. If not specified, the caption will be generated from the latest version. (ISO 8601 Date String) (optional, default to '')
     * @param  string $emit_speaker_change_tokens_as Determine what characters to use to denote speaker changes. (optional, default to '>>')
     * @param  string $force_case Force the contents of the captions to be all UPPER or lower case. If blank, the case of the captions is not changed. (optional, default to '')
     * @param  string $include_dfxp_metadata When true, and the caption format requested is DFXP, the jobs name, ID and language will be added to the DFXP metadata header. When false, these data are omitted from the header. Ignored if caption_format does not equal DFXP. (optional, default to 'true')
     * @param  int $layout_target_caption_length_ms Captions generated will, on average, be this duration. However, they may vary significantly based on other parameters you set. (optional, default to 5000)
     * @param  string $line_break_on_sentence Inserts a line break in between sentences that are in the same caption. (optional, default to 'false')
     * @param  string $line_ending_format Determine the end of line (EOL) character to use for the captions. (optional, default to 'UNIX')
     * @param  int $lines_per_caption Number of lines to be displayed for each caption. (optional, default to 2)
     * @param  string $mask_profanity Replace profanity with asterisks. (optional, default to 'false')
     * @param  int $maximum_caption_duration No captions longer than this (in milliseconds) will be produced. If not specified, there is no maximum. (optional)
     * @param  int $merge_gap_interval Captions with a gap between them that is smaller than this (in milliseconds) will have their start and/or end times changed so there is no time gap between the captions. (optional, default to 1000)
     * @param  int $minimum_caption_length_ms Extends the duration of short captions to the this minimum length. Additional time is taken from later caption blocks to meet this minimum time. (optional)
     * @param  int $minimum_gap_between_captions_ms Adds a minimum time between captions such as there will always be some time between captions where no text is displayed. When captions are very close together, time will be removed from the caption duration to make the gap. (optional)
     * @param  string $qt_seamless Does not put time gaps of any kind between caption blocks. Ignored if caption_format does not equal QT. (optional, default to 'false')
     * @param  string $remove_disfluencies Remove verbal disfluencies from the generated transcript. Common disfluencies such as \&quot;um\&quot; and \&quot;ah\&quot; are removed while maintaining appropriate punctuation. (optional, default to 'true')
     * @param  string[] $remove_sounds_list A list of sounds to not show in the caption. This is a JSON style list, and should look like [\&quot;MUSIC\&quot;, \&quot;LAUGH\&quot;]. Ignored if remove_sound_references is true. (optional)
     * @param  string $remove_sound_references Remove ALL non-verbal sound and noise references from the generated transcript. Sounds and unidentified noises are depicted in the caption as [SOUND], [COUGH] and [NOISE]. If this parameter is set, these identifiers are omitted from the caption. (optional, default to 'true')
     * @param  string $replace_slang Replace common slang terms from the generated transcript. Common replacements are \&quot;want to\&quot; for \&quot;wanna\&quot;, \&quot;going to\&quot; for \&quot;gonna\&quot;, etc. (optional, default to 'false')
     * @param  int $silence_max_ms If there is a interval of silence in the middle of a sentence longer than this, then the caption will be split. (optional, default to 2000)
     * @param  string $single_speaker_per_caption When true, puts each speaker into its own caption. When false, more than one speaker may appear in a single caption. (optional, default to 'true')
     * @param  string[] $sound_boundaries Specifies the characters to surround sound references with. The default will generate sound references that look like this: [MUSIC]. (optional)
     * @param  int $sound_threshold Sound references that are longer than this threshold will be made their own caption entirely, and will not have any text included with them. If not set, Sound references will be included back to back with text no matter the duration of the sound. (optional)
     * @param  string $sound_tokens_by_caption If true, all sound references will always be in their own caption. If false, more than one sound reference may appear in a single caption. (optional, default to 'false')
     * @param  string $sound_tokens_by_line If true, all sound references will always be in their own line. If false, more than one sound reference may appear in a single line. (optional, default to 'false')
     * @param  string[] $sound_tokens_by_caption_list If non-empty, the specified sound references will always be in their own caption. If empty, more than one sound reference may appear in a single caption. Ignored if sound_tokens_by_caption is true. (optional)
     * @param  string[] $sound_tokens_by_line_list If non-empty, the specified sound references will always be in their own line. If empty, more than one sound reference may appear in a single line. Ignored if sound_tokens_by_line is true. (optional)
     * @param  string $speaker_on_new_line If true, a speaker change will cause a new caption to be made. If false, multiple speakers may appear in a single caption. (optional, default to 'true')
     * @param  string $srt_format If the caption format is SRT, determines what the caption blocks will look like. The default, prints caption blocks that look like this:    1:   00:00:06,060 --&gt; 00:00:16,060   This is the caption text.  You can alter the caption block by re-arranging or removing the substitution string values, shown enclosed in braces \&quot;{}\&quot; in the default value below. Substitution strings may used more than once if desired. Any text that is not a substitution string will be displayed as written. To add new lines, include a \\n. Note, you may need to escape the \\n with an extra backslash when encoding the request. (optional, default to '{caption_number:d}\n{start_hour:02d}:{start_minute:02d}:{start_second:02d},{start_millisecond:03d} -->{end_hour:02d}:{end_minute:02d}:{end_second:02d},{end_millisecond:03d}\n{caption_text}\n\n')
     * @param  string $strip_square_brackets Removes all square brackets like &#39;[&#39; or &#39;]&#39; from captions. By default square brackets surround sound references like &#39;[MUSIC]&#39;, but they may exist as part of the caption text as well. (optional, default to 'false')
     * @param  string $utf8_mark Adds a utf8 bytemark to the beginning of the caption. This should only be used if the system you are loading the caption files into needs a byte marker. The vast majority of systems do not. (optional, default to 'false')
     * @param  string $replace_english_spelling Replaces English spelling with location accurate spelling. i.e. Color --&gt; Colour  A: American  B: British  Z: British ize  U: Australian  C: Canadian (optional, default to 'A')
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getCaptionAsync($v, $job_id, $caption_format, $build_url = 'false', $caption_words_min = 1, $caption_by_sentence = 'true', $characters_per_caption_line = 42, $dfxp_header = '', $disallow_dangling = 'false', $display_effects_speaker_as = 'Effects', $display_speaker_id = 'name', $iwp_name = '', $elementlist_version = '', $emit_speaker_change_tokens_as = '>>', $force_case = '', $include_dfxp_metadata = 'true', $layout_target_caption_length_ms = 5000, $line_break_on_sentence = 'false', $line_ending_format = 'UNIX', $lines_per_caption = 2, $mask_profanity = 'false', $maximum_caption_duration = null, $merge_gap_interval = 1000, $minimum_caption_length_ms = null, $minimum_gap_between_captions_ms = null, $qt_seamless = 'false', $remove_disfluencies = 'true', $remove_sounds_list = null, $remove_sound_references = 'true', $replace_slang = 'false', $silence_max_ms = 2000, $single_speaker_per_caption = 'true', $sound_boundaries = null, $sound_threshold = null, $sound_tokens_by_caption = 'false', $sound_tokens_by_line = 'false', $sound_tokens_by_caption_list = null, $sound_tokens_by_line_list = null, $speaker_on_new_line = 'true', $srt_format = '{caption_number:d}\n{start_hour:02d}:{start_minute:02d}:{start_second:02d},{start_millisecond:03d} -->{end_hour:02d}:{end_minute:02d}:{end_second:02d},{end_millisecond:03d}\n{caption_text}\n\n', $strip_square_brackets = 'false', $utf8_mark = 'false', $replace_english_spelling = 'A')
    {
        return $this->getCaptionAsyncWithHttpInfo($v, $job_id, $caption_format, $build_url, $caption_words_min, $caption_by_sentence, $characters_per_caption_line, $dfxp_header, $disallow_dangling, $display_effects_speaker_as, $display_speaker_id, $iwp_name, $elementlist_version, $emit_speaker_change_tokens_as, $force_case, $include_dfxp_metadata, $layout_target_caption_length_ms, $line_break_on_sentence, $line_ending_format, $lines_per_caption, $mask_profanity, $maximum_caption_duration, $merge_gap_interval, $minimum_caption_length_ms, $minimum_gap_between_captions_ms, $qt_seamless, $remove_disfluencies, $remove_sounds_list, $remove_sound_references, $replace_slang, $silence_max_ms, $single_speaker_per_caption, $sound_boundaries, $sound_threshold, $sound_tokens_by_caption, $sound_tokens_by_line, $sound_tokens_by_caption_list, $sound_tokens_by_line_list, $speaker_on_new_line, $srt_format, $strip_square_brackets, $utf8_mark, $replace_english_spelling)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getCaptionAsyncWithHttpInfo
     *
     * @param  int $v (required)
     * @param  string $job_id (required)
     * @param  string $caption_format (required)
     * @param  string $build_url Rather than returning the file, return a permanent URL to the file. (optional, default to 'false')
     * @param  int $caption_words_min Minimum number of words allowed in a caption. (optional, default to 1)
     * @param  string $caption_by_sentence When true, puts each sentence into its own caption. When false, more than one sentence may appear in a single caption. (optional, default to 'true')
     * @param  int $characters_per_caption_line Maximum number of characters to be displayed on each caption line. (optional, default to 42)
     * @param  string $dfxp_header Allows you to specify a custom header for your DFXP caption file. The header should be the entire contents of the header including the opening and closing tags. Ignored if caption_format does not equal DFXP. (optional, default to '')
     * @param  string $disallow_dangling Will prevent captions from having the last word in a sentence start a new line. Last words will ALWAYS be kept on the same line, even if it breaks the characters_per_caption_line option. (optional, default to 'false')
     * @param  string $display_effects_speaker_as Determines what speaker name should used for sound effects. (optional, default to 'Effects')
     * @param  string $display_speaker_id Determines the way speakers are identified in the captions. Choose \&quot;no\&quot; to not display speaker identities at all: \&quot;&gt;&gt; example\&quot; Choose \&quot;number\&quot; to display only the speaker number: \&quot;&gt;&gt; Speaker 1: example\&quot; Choose \&quot;name\&quot; to display the speaker name: \&quot;&gt;&gt; John Doe: example\&quot;. If you choose \&quot;name\&quot;, the speaker number will be displayed if the name is not available. (optional, default to 'name')
     * @param  string $iwp_name The named version of element list to generate the transcript from. If not specified, the transcript will be generated from the latest version. (optional, default to '')
     * @param  string $elementlist_version The version of element list to generate the captions from. If not specified, the caption will be generated from the latest version. (ISO 8601 Date String) (optional, default to '')
     * @param  string $emit_speaker_change_tokens_as Determine what characters to use to denote speaker changes. (optional, default to '>>')
     * @param  string $force_case Force the contents of the captions to be all UPPER or lower case. If blank, the case of the captions is not changed. (optional, default to '')
     * @param  string $include_dfxp_metadata When true, and the caption format requested is DFXP, the jobs name, ID and language will be added to the DFXP metadata header. When false, these data are omitted from the header. Ignored if caption_format does not equal DFXP. (optional, default to 'true')
     * @param  int $layout_target_caption_length_ms Captions generated will, on average, be this duration. However, they may vary significantly based on other parameters you set. (optional, default to 5000)
     * @param  string $line_break_on_sentence Inserts a line break in between sentences that are in the same caption. (optional, default to 'false')
     * @param  string $line_ending_format Determine the end of line (EOL) character to use for the captions. (optional, default to 'UNIX')
     * @param  int $lines_per_caption Number of lines to be displayed for each caption. (optional, default to 2)
     * @param  string $mask_profanity Replace profanity with asterisks. (optional, default to 'false')
     * @param  int $maximum_caption_duration No captions longer than this (in milliseconds) will be produced. If not specified, there is no maximum. (optional)
     * @param  int $merge_gap_interval Captions with a gap between them that is smaller than this (in milliseconds) will have their start and/or end times changed so there is no time gap between the captions. (optional, default to 1000)
     * @param  int $minimum_caption_length_ms Extends the duration of short captions to the this minimum length. Additional time is taken from later caption blocks to meet this minimum time. (optional)
     * @param  int $minimum_gap_between_captions_ms Adds a minimum time between captions such as there will always be some time between captions where no text is displayed. When captions are very close together, time will be removed from the caption duration to make the gap. (optional)
     * @param  string $qt_seamless Does not put time gaps of any kind between caption blocks. Ignored if caption_format does not equal QT. (optional, default to 'false')
     * @param  string $remove_disfluencies Remove verbal disfluencies from the generated transcript. Common disfluencies such as \&quot;um\&quot; and \&quot;ah\&quot; are removed while maintaining appropriate punctuation. (optional, default to 'true')
     * @param  string[] $remove_sounds_list A list of sounds to not show in the caption. This is a JSON style list, and should look like [\&quot;MUSIC\&quot;, \&quot;LAUGH\&quot;]. Ignored if remove_sound_references is true. (optional)
     * @param  string $remove_sound_references Remove ALL non-verbal sound and noise references from the generated transcript. Sounds and unidentified noises are depicted in the caption as [SOUND], [COUGH] and [NOISE]. If this parameter is set, these identifiers are omitted from the caption. (optional, default to 'true')
     * @param  string $replace_slang Replace common slang terms from the generated transcript. Common replacements are \&quot;want to\&quot; for \&quot;wanna\&quot;, \&quot;going to\&quot; for \&quot;gonna\&quot;, etc. (optional, default to 'false')
     * @param  int $silence_max_ms If there is a interval of silence in the middle of a sentence longer than this, then the caption will be split. (optional, default to 2000)
     * @param  string $single_speaker_per_caption When true, puts each speaker into its own caption. When false, more than one speaker may appear in a single caption. (optional, default to 'true')
     * @param  string[] $sound_boundaries Specifies the characters to surround sound references with. The default will generate sound references that look like this: [MUSIC]. (optional)
     * @param  int $sound_threshold Sound references that are longer than this threshold will be made their own caption entirely, and will not have any text included with them. If not set, Sound references will be included back to back with text no matter the duration of the sound. (optional)
     * @param  string $sound_tokens_by_caption If true, all sound references will always be in their own caption. If false, more than one sound reference may appear in a single caption. (optional, default to 'false')
     * @param  string $sound_tokens_by_line If true, all sound references will always be in their own line. If false, more than one sound reference may appear in a single line. (optional, default to 'false')
     * @param  string[] $sound_tokens_by_caption_list If non-empty, the specified sound references will always be in their own caption. If empty, more than one sound reference may appear in a single caption. Ignored if sound_tokens_by_caption is true. (optional)
     * @param  string[] $sound_tokens_by_line_list If non-empty, the specified sound references will always be in their own line. If empty, more than one sound reference may appear in a single line. Ignored if sound_tokens_by_line is true. (optional)
     * @param  string $speaker_on_new_line If true, a speaker change will cause a new caption to be made. If false, multiple speakers may appear in a single caption. (optional, default to 'true')
     * @param  string $srt_format If the caption format is SRT, determines what the caption blocks will look like. The default, prints caption blocks that look like this:    1:   00:00:06,060 --&gt; 00:00:16,060   This is the caption text.  You can alter the caption block by re-arranging or removing the substitution string values, shown enclosed in braces \&quot;{}\&quot; in the default value below. Substitution strings may used more than once if desired. Any text that is not a substitution string will be displayed as written. To add new lines, include a \\n. Note, you may need to escape the \\n with an extra backslash when encoding the request. (optional, default to '{caption_number:d}\n{start_hour:02d}:{start_minute:02d}:{start_second:02d},{start_millisecond:03d} -->{end_hour:02d}:{end_minute:02d}:{end_second:02d},{end_millisecond:03d}\n{caption_text}\n\n')
     * @param  string $strip_square_brackets Removes all square brackets like &#39;[&#39; or &#39;]&#39; from captions. By default square brackets surround sound references like &#39;[MUSIC]&#39;, but they may exist as part of the caption text as well. (optional, default to 'false')
     * @param  string $utf8_mark Adds a utf8 bytemark to the beginning of the caption. This should only be used if the system you are loading the caption files into needs a byte marker. The vast majority of systems do not. (optional, default to 'false')
     * @param  string $replace_english_spelling Replaces English spelling with location accurate spelling. i.e. Color --&gt; Colour  A: American  B: British  Z: British ize  U: Australian  C: Canadian (optional, default to 'A')
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getCaptionAsyncWithHttpInfo($v, $job_id, $caption_format, $build_url = 'false', $caption_words_min = 1, $caption_by_sentence = 'true', $characters_per_caption_line = 42, $dfxp_header = '', $disallow_dangling = 'false', $display_effects_speaker_as = 'Effects', $display_speaker_id = 'name', $iwp_name = '', $elementlist_version = '', $emit_speaker_change_tokens_as = '>>', $force_case = '', $include_dfxp_metadata = 'true', $layout_target_caption_length_ms = 5000, $line_break_on_sentence = 'false', $line_ending_format = 'UNIX', $lines_per_caption = 2, $mask_profanity = 'false', $maximum_caption_duration = null, $merge_gap_interval = 1000, $minimum_caption_length_ms = null, $minimum_gap_between_captions_ms = null, $qt_seamless = 'false', $remove_disfluencies = 'true', $remove_sounds_list = null, $remove_sound_references = 'true', $replace_slang = 'false', $silence_max_ms = 2000, $single_speaker_per_caption = 'true', $sound_boundaries = null, $sound_threshold = null, $sound_tokens_by_caption = 'false', $sound_tokens_by_line = 'false', $sound_tokens_by_caption_list = null, $sound_tokens_by_line_list = null, $speaker_on_new_line = 'true', $srt_format = '{caption_number:d}\n{start_hour:02d}:{start_minute:02d}:{start_second:02d},{start_millisecond:03d} -->{end_hour:02d}:{end_minute:02d}:{end_second:02d},{end_millisecond:03d}\n{caption_text}\n\n', $strip_square_brackets = 'false', $utf8_mark = 'false', $replace_english_spelling = 'A')
    {
        $returnType = 'string';
        $request = $this->getCaptionRequest($v, $job_id, $caption_format, $build_url, $caption_words_min, $caption_by_sentence, $characters_per_caption_line, $dfxp_header, $disallow_dangling, $display_effects_speaker_as, $display_speaker_id, $iwp_name, $elementlist_version, $emit_speaker_change_tokens_as, $force_case, $include_dfxp_metadata, $layout_target_caption_length_ms, $line_break_on_sentence, $line_ending_format, $lines_per_caption, $mask_profanity, $maximum_caption_duration, $merge_gap_interval, $minimum_caption_length_ms, $minimum_gap_between_captions_ms, $qt_seamless, $remove_disfluencies, $remove_sounds_list, $remove_sound_references, $replace_slang, $silence_max_ms, $single_speaker_per_caption, $sound_boundaries, $sound_threshold, $sound_tokens_by_caption, $sound_tokens_by_line, $sound_tokens_by_caption_list, $sound_tokens_by_line_list, $speaker_on_new_line, $srt_format, $strip_square_brackets, $utf8_mark, $replace_english_spelling);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getCaption'
     *
     * @param  int $v (required)
     * @param  string $job_id (required)
     * @param  string $caption_format (required)
     * @param  string $build_url Rather than returning the file, return a permanent URL to the file. (optional, default to 'false')
     * @param  int $caption_words_min Minimum number of words allowed in a caption. (optional, default to 1)
     * @param  string $caption_by_sentence When true, puts each sentence into its own caption. When false, more than one sentence may appear in a single caption. (optional, default to 'true')
     * @param  int $characters_per_caption_line Maximum number of characters to be displayed on each caption line. (optional, default to 42)
     * @param  string $dfxp_header Allows you to specify a custom header for your DFXP caption file. The header should be the entire contents of the header including the opening and closing tags. Ignored if caption_format does not equal DFXP. (optional, default to '')
     * @param  string $disallow_dangling Will prevent captions from having the last word in a sentence start a new line. Last words will ALWAYS be kept on the same line, even if it breaks the characters_per_caption_line option. (optional, default to 'false')
     * @param  string $display_effects_speaker_as Determines what speaker name should used for sound effects. (optional, default to 'Effects')
     * @param  string $display_speaker_id Determines the way speakers are identified in the captions. Choose \&quot;no\&quot; to not display speaker identities at all: \&quot;&gt;&gt; example\&quot; Choose \&quot;number\&quot; to display only the speaker number: \&quot;&gt;&gt; Speaker 1: example\&quot; Choose \&quot;name\&quot; to display the speaker name: \&quot;&gt;&gt; John Doe: example\&quot;. If you choose \&quot;name\&quot;, the speaker number will be displayed if the name is not available. (optional, default to 'name')
     * @param  string $iwp_name The named version of element list to generate the transcript from. If not specified, the transcript will be generated from the latest version. (optional, default to '')
     * @param  string $elementlist_version The version of element list to generate the captions from. If not specified, the caption will be generated from the latest version. (ISO 8601 Date String) (optional, default to '')
     * @param  string $emit_speaker_change_tokens_as Determine what characters to use to denote speaker changes. (optional, default to '>>')
     * @param  string $force_case Force the contents of the captions to be all UPPER or lower case. If blank, the case of the captions is not changed. (optional, default to '')
     * @param  string $include_dfxp_metadata When true, and the caption format requested is DFXP, the jobs name, ID and language will be added to the DFXP metadata header. When false, these data are omitted from the header. Ignored if caption_format does not equal DFXP. (optional, default to 'true')
     * @param  int $layout_target_caption_length_ms Captions generated will, on average, be this duration. However, they may vary significantly based on other parameters you set. (optional, default to 5000)
     * @param  string $line_break_on_sentence Inserts a line break in between sentences that are in the same caption. (optional, default to 'false')
     * @param  string $line_ending_format Determine the end of line (EOL) character to use for the captions. (optional, default to 'UNIX')
     * @param  int $lines_per_caption Number of lines to be displayed for each caption. (optional, default to 2)
     * @param  string $mask_profanity Replace profanity with asterisks. (optional, default to 'false')
     * @param  int $maximum_caption_duration No captions longer than this (in milliseconds) will be produced. If not specified, there is no maximum. (optional)
     * @param  int $merge_gap_interval Captions with a gap between them that is smaller than this (in milliseconds) will have their start and/or end times changed so there is no time gap between the captions. (optional, default to 1000)
     * @param  int $minimum_caption_length_ms Extends the duration of short captions to the this minimum length. Additional time is taken from later caption blocks to meet this minimum time. (optional)
     * @param  int $minimum_gap_between_captions_ms Adds a minimum time between captions such as there will always be some time between captions where no text is displayed. When captions are very close together, time will be removed from the caption duration to make the gap. (optional)
     * @param  string $qt_seamless Does not put time gaps of any kind between caption blocks. Ignored if caption_format does not equal QT. (optional, default to 'false')
     * @param  string $remove_disfluencies Remove verbal disfluencies from the generated transcript. Common disfluencies such as \&quot;um\&quot; and \&quot;ah\&quot; are removed while maintaining appropriate punctuation. (optional, default to 'true')
     * @param  string[] $remove_sounds_list A list of sounds to not show in the caption. This is a JSON style list, and should look like [\&quot;MUSIC\&quot;, \&quot;LAUGH\&quot;]. Ignored if remove_sound_references is true. (optional)
     * @param  string $remove_sound_references Remove ALL non-verbal sound and noise references from the generated transcript. Sounds and unidentified noises are depicted in the caption as [SOUND], [COUGH] and [NOISE]. If this parameter is set, these identifiers are omitted from the caption. (optional, default to 'true')
     * @param  string $replace_slang Replace common slang terms from the generated transcript. Common replacements are \&quot;want to\&quot; for \&quot;wanna\&quot;, \&quot;going to\&quot; for \&quot;gonna\&quot;, etc. (optional, default to 'false')
     * @param  int $silence_max_ms If there is a interval of silence in the middle of a sentence longer than this, then the caption will be split. (optional, default to 2000)
     * @param  string $single_speaker_per_caption When true, puts each speaker into its own caption. When false, more than one speaker may appear in a single caption. (optional, default to 'true')
     * @param  string[] $sound_boundaries Specifies the characters to surround sound references with. The default will generate sound references that look like this: [MUSIC]. (optional)
     * @param  int $sound_threshold Sound references that are longer than this threshold will be made their own caption entirely, and will not have any text included with them. If not set, Sound references will be included back to back with text no matter the duration of the sound. (optional)
     * @param  string $sound_tokens_by_caption If true, all sound references will always be in their own caption. If false, more than one sound reference may appear in a single caption. (optional, default to 'false')
     * @param  string $sound_tokens_by_line If true, all sound references will always be in their own line. If false, more than one sound reference may appear in a single line. (optional, default to 'false')
     * @param  string[] $sound_tokens_by_caption_list If non-empty, the specified sound references will always be in their own caption. If empty, more than one sound reference may appear in a single caption. Ignored if sound_tokens_by_caption is true. (optional)
     * @param  string[] $sound_tokens_by_line_list If non-empty, the specified sound references will always be in their own line. If empty, more than one sound reference may appear in a single line. Ignored if sound_tokens_by_line is true. (optional)
     * @param  string $speaker_on_new_line If true, a speaker change will cause a new caption to be made. If false, multiple speakers may appear in a single caption. (optional, default to 'true')
     * @param  string $srt_format If the caption format is SRT, determines what the caption blocks will look like. The default, prints caption blocks that look like this:    1:   00:00:06,060 --&gt; 00:00:16,060   This is the caption text.  You can alter the caption block by re-arranging or removing the substitution string values, shown enclosed in braces \&quot;{}\&quot; in the default value below. Substitution strings may used more than once if desired. Any text that is not a substitution string will be displayed as written. To add new lines, include a \\n. Note, you may need to escape the \\n with an extra backslash when encoding the request. (optional, default to '{caption_number:d}\n{start_hour:02d}:{start_minute:02d}:{start_second:02d},{start_millisecond:03d} -->{end_hour:02d}:{end_minute:02d}:{end_second:02d},{end_millisecond:03d}\n{caption_text}\n\n')
     * @param  string $strip_square_brackets Removes all square brackets like &#39;[&#39; or &#39;]&#39; from captions. By default square brackets surround sound references like &#39;[MUSIC]&#39;, but they may exist as part of the caption text as well. (optional, default to 'false')
     * @param  string $utf8_mark Adds a utf8 bytemark to the beginning of the caption. This should only be used if the system you are loading the caption files into needs a byte marker. The vast majority of systems do not. (optional, default to 'false')
     * @param  string $replace_english_spelling Replaces English spelling with location accurate spelling. i.e. Color --&gt; Colour  A: American  B: British  Z: British ize  U: Australian  C: Canadian (optional, default to 'A')
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getCaptionRequest($v, $job_id, $caption_format, $build_url = 'false', $caption_words_min = 1, $caption_by_sentence = 'true', $characters_per_caption_line = 42, $dfxp_header = '', $disallow_dangling = 'false', $display_effects_speaker_as = 'Effects', $display_speaker_id = 'name', $iwp_name = '', $elementlist_version = '', $emit_speaker_change_tokens_as = '>>', $force_case = '', $include_dfxp_metadata = 'true', $layout_target_caption_length_ms = 5000, $line_break_on_sentence = 'false', $line_ending_format = 'UNIX', $lines_per_caption = 2, $mask_profanity = 'false', $maximum_caption_duration = null, $merge_gap_interval = 1000, $minimum_caption_length_ms = null, $minimum_gap_between_captions_ms = null, $qt_seamless = 'false', $remove_disfluencies = 'true', $remove_sounds_list = null, $remove_sound_references = 'true', $replace_slang = 'false', $silence_max_ms = 2000, $single_speaker_per_caption = 'true', $sound_boundaries = null, $sound_threshold = null, $sound_tokens_by_caption = 'false', $sound_tokens_by_line = 'false', $sound_tokens_by_caption_list = null, $sound_tokens_by_line_list = null, $speaker_on_new_line = 'true', $srt_format = '{caption_number:d}\n{start_hour:02d}:{start_minute:02d}:{start_second:02d},{start_millisecond:03d} -->{end_hour:02d}:{end_minute:02d}:{end_second:02d},{end_millisecond:03d}\n{caption_text}\n\n', $strip_square_brackets = 'false', $utf8_mark = 'false', $replace_english_spelling = 'A')
    {
        // verify the required parameter 'v' is set
        if ($v === null || (is_array($v) && count($v) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $v when calling getCaption'
            );
        }
        // verify the required parameter 'job_id' is set
        if ($job_id === null || (is_array($job_id) && count($job_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $job_id when calling getCaption'
            );
        }
        // verify the required parameter 'caption_format' is set
        if ($caption_format === null || (is_array($caption_format) && count($caption_format) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $caption_format when calling getCaption'
            );
        }


        $resourcePath = '/job/get_caption';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $v,
            'v', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $job_id,
            'job_id', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $caption_format,
            'caption_format', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $build_url,
            'build_url', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $caption_words_min,
            'caption_words_min', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $caption_by_sentence,
            'caption_by_sentence', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $characters_per_caption_line,
            'characters_per_caption_line', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $dfxp_header,
            'dfxp_header', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $disallow_dangling,
            'disallow_dangling', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $display_effects_speaker_as,
            'display_effects_speaker_as', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $display_speaker_id,
            'display_speaker_id', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $iwp_name,
            'iwp_name', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $elementlist_version,
            'elementlist_version', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $emit_speaker_change_tokens_as,
            'emit_speaker_change_tokens_as', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $force_case,
            'force_case', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $include_dfxp_metadata,
            'include_dfxp_metadata', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $layout_target_caption_length_ms,
            'layout_target_caption_length_ms', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $line_break_on_sentence,
            'line_break_on_sentence', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $line_ending_format,
            'line_ending_format', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $lines_per_caption,
            'lines_per_caption', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $mask_profanity,
            'mask_profanity', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $maximum_caption_duration,
            'maximum_caption_duration', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $merge_gap_interval,
            'merge_gap_interval', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $minimum_caption_length_ms,
            'minimum_caption_length_ms', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $minimum_gap_between_captions_ms,
            'minimum_gap_between_captions_ms', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $qt_seamless,
            'qt_seamless', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $remove_disfluencies,
            'remove_disfluencies', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $remove_sounds_list,
            'remove_sounds_list', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $remove_sound_references,
            'remove_sound_references', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $replace_slang,
            'replace_slang', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $silence_max_ms,
            'silence_max_ms', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $single_speaker_per_caption,
            'single_speaker_per_caption', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sound_boundaries,
            'sound_boundaries', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sound_threshold,
            'sound_threshold', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sound_tokens_by_caption,
            'sound_tokens_by_caption', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sound_tokens_by_line,
            'sound_tokens_by_line', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sound_tokens_by_caption_list,
            'sound_tokens_by_caption_list', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sound_tokens_by_line_list,
            'sound_tokens_by_line_list', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $speaker_on_new_line,
            'speaker_on_new_line', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $srt_format,
            'srt_format', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $strip_square_brackets,
            'strip_square_brackets', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $utf8_mark,
            'utf8_mark', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $replace_english_spelling,
            'replace_english_spelling', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain', 'application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('api_token');
        if ($apiKey !== null) {
            $queryParams['api_token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation jobInfo
     *
     * @param  int $v v (required)
     * @param  string $job_id job_id (required)
     *
     * @throws \Cielo24\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Cielo24\Model\JobInfoResponse|\Cielo24\Model\ErrorResponse
     */
    public function jobInfo($v, $job_id)
    {
        list($response) = $this->jobInfoWithHttpInfo($v, $job_id);
        return $response;
    }

    /**
     * Operation jobInfoWithHttpInfo
     *
     * @param  int $v (required)
     * @param  string $job_id (required)
     *
     * @throws \Cielo24\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Cielo24\Model\JobInfoResponse|\Cielo24\Model\ErrorResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function jobInfoWithHttpInfo($v, $job_id)
    {
        $request = $this->jobInfoRequest($v, $job_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Cielo24\Model\JobInfoResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Cielo24\Model\JobInfoResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Cielo24\Model\JobInfoResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('\Cielo24\Model\ErrorResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Cielo24\Model\ErrorResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Cielo24\Model\ErrorResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Cielo24\Model\JobInfoResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Cielo24\Model\JobInfoResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Cielo24\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation jobInfoAsync
     *
     * @param  int $v (required)
     * @param  string $job_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function jobInfoAsync($v, $job_id)
    {
        return $this->jobInfoAsyncWithHttpInfo($v, $job_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation jobInfoAsyncWithHttpInfo
     *
     * @param  int $v (required)
     * @param  string $job_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function jobInfoAsyncWithHttpInfo($v, $job_id)
    {
        $returnType = '\Cielo24\Model\JobInfoResponse';
        $request = $this->jobInfoRequest($v, $job_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'jobInfo'
     *
     * @param  int $v (required)
     * @param  string $job_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function jobInfoRequest($v, $job_id)
    {
        // verify the required parameter 'v' is set
        if ($v === null || (is_array($v) && count($v) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $v when calling jobInfo'
            );
        }
        // verify the required parameter 'job_id' is set
        if ($job_id === null || (is_array($job_id) && count($job_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $job_id when calling jobInfo'
            );
        }

        $resourcePath = '/job/info';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $v,
            'v', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $job_id,
            'job_id', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);




        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('api_token');
        if ($apiKey !== null) {
            $queryParams['api_token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation newJob
     *
     * @param  int $v v (required)
     * @param  \Cielo24\Model\NewJobBody $new_job_body new_job_body (required)
     *
     * @throws \Cielo24\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Cielo24\Model\NewJobResponse|\Cielo24\Model\ErrorResponse
     */
    public function newJob($v, $new_job_body)
    {
        list($response) = $this->newJobWithHttpInfo($v, $new_job_body);
        return $response;
    }

    /**
     * Operation newJobWithHttpInfo
     *
     * @param  int $v (required)
     * @param  \Cielo24\Model\NewJobBody $new_job_body (required)
     *
     * @throws \Cielo24\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Cielo24\Model\NewJobResponse|\Cielo24\Model\ErrorResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function newJobWithHttpInfo($v, $new_job_body)
    {
        $request = $this->newJobRequest($v, $new_job_body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Cielo24\Model\NewJobResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Cielo24\Model\NewJobResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Cielo24\Model\NewJobResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('\Cielo24\Model\ErrorResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Cielo24\Model\ErrorResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Cielo24\Model\ErrorResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Cielo24\Model\NewJobResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Cielo24\Model\NewJobResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Cielo24\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation newJobAsync
     *
     * @param  int $v (required)
     * @param  \Cielo24\Model\NewJobBody $new_job_body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function newJobAsync($v, $new_job_body)
    {
        return $this->newJobAsyncWithHttpInfo($v, $new_job_body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation newJobAsyncWithHttpInfo
     *
     * @param  int $v (required)
     * @param  \Cielo24\Model\NewJobBody $new_job_body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function newJobAsyncWithHttpInfo($v, $new_job_body)
    {
        $returnType = '\Cielo24\Model\NewJobResponse';
        $request = $this->newJobRequest($v, $new_job_body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'newJob'
     *
     * @param  int $v (required)
     * @param  \Cielo24\Model\NewJobBody $new_job_body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function newJobRequest($v, $new_job_body)
    {
        // verify the required parameter 'v' is set
        if ($v === null || (is_array($v) && count($v) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $v when calling newJob'
            );
        }
        // verify the required parameter 'new_job_body' is set
        if ($new_job_body === null || (is_array($new_job_body) && count($new_job_body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $new_job_body when calling newJob'
            );
        }

        $resourcePath = '/job/new';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $v,
            'v', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);




        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($new_job_body)) {
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($new_job_body));
            } else {
                $httpBody = $new_job_body;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('api_token');
        if ($apiKey !== null) {
            $queryParams['api_token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation performTranscription
     *
     * @param  int $v v (required)
     * @param  \Cielo24\Model\PerformTranscriptionBody $perform_transcription_body perform_transcription_body (required)
     *
     * @throws \Cielo24\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Cielo24\Model\PerformTranscriptionResponse|\Cielo24\Model\ErrorResponse
     */
    public function performTranscription($v, $perform_transcription_body)
    {
        list($response) = $this->performTranscriptionWithHttpInfo($v, $perform_transcription_body);
        return $response;
    }

    /**
     * Operation performTranscriptionWithHttpInfo
     *
     * @param  int $v (required)
     * @param  \Cielo24\Model\PerformTranscriptionBody $perform_transcription_body (required)
     *
     * @throws \Cielo24\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Cielo24\Model\PerformTranscriptionResponse|\Cielo24\Model\ErrorResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function performTranscriptionWithHttpInfo($v, $perform_transcription_body)
    {
        $request = $this->performTranscriptionRequest($v, $perform_transcription_body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Cielo24\Model\PerformTranscriptionResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Cielo24\Model\PerformTranscriptionResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Cielo24\Model\PerformTranscriptionResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('\Cielo24\Model\ErrorResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Cielo24\Model\ErrorResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Cielo24\Model\ErrorResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Cielo24\Model\PerformTranscriptionResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Cielo24\Model\PerformTranscriptionResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Cielo24\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation performTranscriptionAsync
     *
     * @param  int $v (required)
     * @param  \Cielo24\Model\PerformTranscriptionBody $perform_transcription_body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function performTranscriptionAsync($v, $perform_transcription_body)
    {
        return $this->performTranscriptionAsyncWithHttpInfo($v, $perform_transcription_body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation performTranscriptionAsyncWithHttpInfo
     *
     * @param  int $v (required)
     * @param  \Cielo24\Model\PerformTranscriptionBody $perform_transcription_body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function performTranscriptionAsyncWithHttpInfo($v, $perform_transcription_body)
    {
        $returnType = '\Cielo24\Model\PerformTranscriptionResponse';
        $request = $this->performTranscriptionRequest($v, $perform_transcription_body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'performTranscription'
     *
     * @param  int $v (required)
     * @param  \Cielo24\Model\PerformTranscriptionBody $perform_transcription_body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function performTranscriptionRequest($v, $perform_transcription_body)
    {
        // verify the required parameter 'v' is set
        if ($v === null || (is_array($v) && count($v) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $v when calling performTranscription'
            );
        }
        // verify the required parameter 'perform_transcription_body' is set
        if ($perform_transcription_body === null || (is_array($perform_transcription_body) && count($perform_transcription_body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $perform_transcription_body when calling performTranscription'
            );
        }

        $resourcePath = '/job/perform_transcription';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $v,
            'v', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);




        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($perform_transcription_body)) {
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($perform_transcription_body));
            } else {
                $httpBody = $perform_transcription_body;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('api_token');
        if ($apiKey !== null) {
            $queryParams['api_token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation performTranslation
     *
     * @param  int $v v (required)
     * @param  string $job_id job_id (required)
     * @param  string $target_languages The language(s) being ordered (Any RFC 5646 language code) separated by comma (,) (required)
     * @param  string $approve_uplevel approve_uplevel (optional)
     *
     * @throws \Cielo24\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Cielo24\Model\PerformTranslationResponse|\Cielo24\Model\ErrorResponse
     */
    public function performTranslation($v, $job_id, $target_languages, $approve_uplevel = null)
    {
        list($response) = $this->performTranslationWithHttpInfo($v, $job_id, $target_languages, $approve_uplevel);
        return $response;
    }

    /**
     * Operation performTranslationWithHttpInfo
     *
     * @param  int $v (required)
     * @param  string $job_id (required)
     * @param  string $target_languages The language(s) being ordered (Any RFC 5646 language code) separated by comma (,) (required)
     * @param  string $approve_uplevel (optional)
     *
     * @throws \Cielo24\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Cielo24\Model\PerformTranslationResponse|\Cielo24\Model\ErrorResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function performTranslationWithHttpInfo($v, $job_id, $target_languages, $approve_uplevel = null)
    {
        $request = $this->performTranslationRequest($v, $job_id, $target_languages, $approve_uplevel);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 201:
                    if ('\Cielo24\Model\PerformTranslationResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Cielo24\Model\PerformTranslationResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Cielo24\Model\PerformTranslationResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('\Cielo24\Model\ErrorResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Cielo24\Model\ErrorResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Cielo24\Model\ErrorResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Cielo24\Model\PerformTranslationResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Cielo24\Model\PerformTranslationResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Cielo24\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation performTranslationAsync
     *
     * @param  int $v (required)
     * @param  string $job_id (required)
     * @param  string $target_languages The language(s) being ordered (Any RFC 5646 language code) separated by comma (,) (required)
     * @param  string $approve_uplevel (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function performTranslationAsync($v, $job_id, $target_languages, $approve_uplevel = null)
    {
        return $this->performTranslationAsyncWithHttpInfo($v, $job_id, $target_languages, $approve_uplevel)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation performTranslationAsyncWithHttpInfo
     *
     * @param  int $v (required)
     * @param  string $job_id (required)
     * @param  string $target_languages The language(s) being ordered (Any RFC 5646 language code) separated by comma (,) (required)
     * @param  string $approve_uplevel (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function performTranslationAsyncWithHttpInfo($v, $job_id, $target_languages, $approve_uplevel = null)
    {
        $returnType = '\Cielo24\Model\PerformTranslationResponse';
        $request = $this->performTranslationRequest($v, $job_id, $target_languages, $approve_uplevel);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'performTranslation'
     *
     * @param  int $v (required)
     * @param  string $job_id (required)
     * @param  string $target_languages The language(s) being ordered (Any RFC 5646 language code) separated by comma (,) (required)
     * @param  string $approve_uplevel (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function performTranslationRequest($v, $job_id, $target_languages, $approve_uplevel = null)
    {
        // verify the required parameter 'v' is set
        if ($v === null || (is_array($v) && count($v) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $v when calling performTranslation'
            );
        }
        // verify the required parameter 'job_id' is set
        if ($job_id === null || (is_array($job_id) && count($job_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $job_id when calling performTranslation'
            );
        }
        // verify the required parameter 'target_languages' is set
        if ($target_languages === null || (is_array($target_languages) && count($target_languages) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $target_languages when calling performTranslation'
            );
        }

        $resourcePath = '/job/translate';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $v,
            'v', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $job_id,
            'job_id', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $target_languages,
            'target_languages', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $approve_uplevel,
            'approve_uplevel', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('api_token');
        if ($apiKey !== null) {
            $queryParams['api_token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
